package data_encoder

type DataInput = []interface{}

// Message size constraints.
const (
	// The max number of bytes that can be contained within a string.
	MaxStringLength = 1_000_000

	// The number of bytes required to store the number of bytes contained within
	// a string.
	StringLengthEncBytes = 3

	// The maximum number of elements that can be stored in a DataInput instance.
	MaxDataInputElements = 1_000

	// The number of bytes required to store the number of elements in a DataInput.
	DataInputLengthEncBytes = 2

	// MaxEncodedDataLen is the maximum size of a message which can be generated by the
	// current version of the encoding software. If a message is larger than this, it's
	// likely malformed or malicious.
	MaxEncodedDataLen = 1 + (MaxDataInputElements * (1 + StringLengthEncBytes + MaxStringLength))
)

// Field tags.
const (
	// The current message encoding version. Used by the decoder to determine if
	// it can decode a particular message.
	CurrentVersion byte = 0

	// DataInput field tag.
	//
	// Next 2 bytes in message contain a little-endian short, specifying the number of
	// elements in the DataInput. The next byte is either (a) the tag of the first element
	// in the DataInput, (b) the tag of the element which comes after the 0-length DataInput
	// instance, or (c) past the end of the message, in the event the top-level DataInput
	// of the message contains an empty DataInput as its last element.
	DataInputField byte = 0

	// Int32 field tag.
	//
	// Next 4 bytes in message contain a little-endian int32.
	Int32Field byte = 1

	// String field tag.
	//
	// Next 3 bytes in message contain a little-endian integer, specifying the number of
	// bytes in the string. The following N bytes contain the string.
	StringField byte = 2
)

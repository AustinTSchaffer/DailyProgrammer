# CNU PCSE 2016 Programming Competition

This is a repository for solutions to the CNU's 2016 programming challenge problems. These solutions were developed after-the-fact and were not submitted to the competition. The solutions to all of the proposed problems were developed using Java 1.8. No additional dependancies are required.

## 1. Excel-lent!
___ExcellentParser.java___

##### Problem
Users need a utility that can transform a row number and a column number into an address for an cell in an Excel spreadsheet (or a Google Sheets spreadsheet).

##### Sample
|Input (RnCn) | Output (__C__n) |
|-------------|-----------------|
| R1C1        | A1              |
| R26C1       | A26             |
| R1C26       | Z1              |
| R1C27       | AA1             |
| R1C500      | SF1             |
| R53C17576   | YYZ53           |

##### Solution
Each input comes in the form _RnCm_ and has to be changed to ___C__Rn_. The row number can be split off and moved to the end. The column change is a little trickier. Converting the number to base 26 and shifting the characters to the correct position does not work, since the column letterings use implied leading zeroes and do not use trailing zeroes. The following loop transfers a base-10 number into a correctly formatted string.

```java
int colNum = m;
String excelColString = "";

while (colNum > 0) {
    colNum--;
	int remainder = colNum % 26;
	char digit = (char) (remainder + 'A');
	excelColString = digit + excelColString;
	colNum = (colNum - remainder) / 26;
}
```

##### Usage
The solution was developed as a class with static methods. Each row-column pair is converted using _ExcellentParser.parse(String)_, according to the snippet below.

```java
ExcellentParser.parse("R1C1");
ExcellentParser.parse("R3C1");
ExcellentParser.parse("R1C3");
ExcellentParser.parse("R299999999C26");
ExcellentParser.parse("R52C52");
ExcellentParser.parse("R53C17576");
ExcellentParser.parse("R53C17602");
```

The above code returns the following respective outputs.

```
A1
A3
C1
Z299999999
Z52
YYZ53
YZZ53
```

## 2. Sinus Rhythm
___SinusRhythmPlotter.java___

##### Problem
Users need a utility for plotting ASCII triangle waves, according to an integer parameter and a string parameter. The integer extends the amplitude and period of the wave, which will decide the shape of the input string.

##### Solution
Each "wave" is packaged as a number and a string. These two pieces of information are used to generate a set of triangle waves. The number represents the amplitude of the wave. The frequency of the wave is also affected by the amplitude, according to the problem description. The string of characters is used to determine both the length of the wave, and its visual representation. This visual representation is created as a 2D array of characters, sized according to the largest input amplitude and the longest input string. The waves are printed onto this graph according to their input order.

##### Usage
The class uses a builder pattern to pass in wave information. In the class's _build()_ method, a 2D char array is generated, holding an ASCII representation of a graph of the inputs. This array can be accessed as a String, using the _toString()_ method. Below is a code snippet showing the class's usage.

```java
String graph = new SinusRhythmPlotter()
    .addWave(1, "---------------------------------")
    .addWave(6, "+++++++++++++++++++++++++++++++")
    .addWave(0, "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX")
    .addWave(-3, "@@@@@@@@@@@@@@@@@@@@")
    .build()
    .toString();
```

The string in the above code sample holds the following graph. The graph's borders are not produced in the code and were included manually as a visual aid.

```
 _________________________________
|     +                   +       |
|    + +                 + +      |
|   +   +               +   +     |
|  +   @ +     @       +     +    |
| +   @ @ +   @ @     +       +   |
|@---@---@-+-@---@---+---------+--|
| @ @     @ @     @ @             |
|  @       @ +     @              |
|             +   +               |
|              + +                |
|               +                 |
|_________________________________|
```

## 3. Kickin' it Old School
___NumpadWordMatcher.java___

##### Problem
Users need a utility for determining if specific strings can be generated using specific number sequences, according to the number pads on their phones.

##### Solution
This problem was the easiest of the 5. The most difficult part is transforming a string of numbers into a list of letter combinations, according to a specified mapping. This part of the problem is handled in the class's _getAllCombinations(String numbers)_ method. The method recursively generates a list of all the character sequences that can be generated by a string of numbers, according to a number pad. This list of strings is then compared to all of the input strings, to determine which, if any, could be generated by any of the input number sequences. This method has a high time complexity, because I really wanted some recursion practice. In practicality, most solutions are better left non-recursive. A better solution would be to check each string against each input number sequence.

##### Recursive Method Pseudo Code

```
getAllCombinations(string s)
	input: string of numbers
	output: list of combinations
	
	If s is empty
		Return list { "" }
	list li = getAllCombinations(s.sub(1))
	int i = (int) (s.charAt(0) - '0')
	list out
	For each string in li
		For each letter mapped by i
			Add (letter + string) to out
	Return out
```

##### Usage
This class holds also implements a builder-like pattern and is called as follows.

```java
ArrayList<String> matches = new NumpadWordMatcher()
    .addDictionaryEntry("JOVE")
    .addDictionaryEntry("CLOVE")
    .addDictionaryEntry("BAD")
    .addDictionaryEntry("LOUD")
    .addDictionaryEntry("LOVE")
    .addDictionaryEntry("GLOVE")
    .addKeyStroke("5683")
    .addKeyStroke("223")
    .execute();
```

The above list contains the following four input strings. Of the six input strings, these four can be produced using either the 5683 number sequence or the 223 number sequence.

```
BAD
JOVE
LOUD
LOVE
```

## 4. Tipping the Nest
___ProperNestingVerifier.java___

##### Problem
Users need a utility for processing lines of HTML. Specifically, they need a small software package for verifying that a series of HTML tags is properly nested.

##### Solution
The class verifies an HTML string by using a stack and a queue. Both structures use a custom object type, named "Tag", which holds the name of an HTML tag and a flag to show if the tag is an opening or closing tag. The queue holds the order of the HTML tags in the string, including an assumed closing "#" tag at the end. The stack holds the current nexting hierarchy of the previously processed tags. The bottom-most element in the stack is an assumed opening "#" tag. If the next tag in the queue is an opening tag, then it is pushed onto the stack. If the next tag in the queue is a closing tag, then a tag is popped off the stack. If the current closing tag does not match the opening tag that was popped off the stack, then the HTML string was not properly nested. If they do match, then the process continues until the closing "#" is matched with the opening "#".

##### Usage
The Proper Nesting Verifier is a class containing static methods and reads each HTML string line-by-line.

```java
ProperNestingVerifier.verify("The following text<C><B>is centered and in boldface</B></C>#");
ProperNestingVerifier.verify("<B>This <\\g>is <B>boldface</B> in <<*> a</B> <\\6> <<d>sentence#");
ProperNestingVerifier.verify("<B><C> This should be centered and in boldface, but the tags are wrongly nested </B></C>#");
ProperNestingVerifier.verify("<B>This should be in boldface, but there is an extra closing <img src='tag.gif'>tag</B></C>#");
ProperNestingVerifier.verify("<B><C>This should be centered and in boldface, but there is a missing closing tag</C>#");
```

The _verify(String)_ method returns a string. The return values from the above method calls are the following strings.

```
VALID
Expected </d>, found #
Expected </C>, found </B>
Expected #, found </C>
Expected </B>, found #
```

## 5. YOLO (TTL)
___YOLOTTL.java___

##### Problem
Users need an simplified implementation of a network for packet analysis. The implementation needs to be able to perform a graph search, limited by an input depth.

##### Solution
The program finds the number of nodes that are reachable from the starting node, given a specific maximum depth, and then subracts that number of nodes from the total number of nodes. Below is the java code that performs the graph search.

```java
List<Node> reachableNodes = new ArrayList<Node>();
List<Node> fringe         = new ArrayList<Node>();
List<Node> fringeBuffer   = new ArrayList<Node>();
		
fringe.add(startingNode);

for (ttl = ttl; ttl >= 0; --ttl) {

	reachableNodes.addAll(fringe);
			
	for (Node n1 : fringe) {
		for (Node n2 : n1.connections()) {
			if (!reachableNodes.contains(n2) && !fringeBuffer.contains(n2)) {
				fringeBuffer.add(n2);
			}
		}
	}

	fringe.clear();
	fringe.addAll(fringeBuffer);
	fringeBuffer.clear();
}

return reachableNodes;
```

The _n1.connections()_ method call returns all of the nodes connected to the node n1. The core of this algorithm is a fringe of nodes that is filled and cleared. The fringe determines which nodes will be expanded next in the search, effectively a breadth first search.

##### Usage
The graph is loaded using a builder pattern. Once the graph is loaded, it can be polled using the _testPacket(uid, ttl)_ method. This method searches for all of the nodes that can be reached from the node numbered _uid_ in _ttl_ or fewer jumps. Below is the method calls used for the second challenge input.

```java
YOLOTTL yolottl = new YOLOTTL()
	.addConnection(1,2)
	.addConnection(1,3)
	.addConnection(2,7)
	.addConnection(3,4)
	.addConnection(3,5)
	.addConnection(4,6)
	.addConnection(5,10)
	.addConnection(5,11)
	.addConnection(6,11)
	.addConnection(7,6)
	.addConnection(7,8)
	.addConnection(7,9)
	.addConnection(8,9)
	.addConnection(8,6);
				

System.out.println(yolottl.testPacket(1,1));
System.out.println(yolottl.testPacket(1,2));
System.out.println(yolottl.testPacket(3,2));
System.out.println(yolottl.testPacket(3,3));
```

The above code outputs the following lines.

```
8 nodes unreachable from node 1 with TTL = 1
5 nodes unreachable from node 1 with TTL = 2
3 nodes unreachable from node 3 with TTL = 2
1 node unreachable from node 3 with TTL = 3
```
